(in-package :cl-user)
(defpackage codex.macros
  (:use :cl :trivial-types)
  (:import-from :common-doc
                :<document-link>
                :<text-node>
                :define-node
                :children
                :text)
  (:import-from :common-doc.macro
                :<macro-node>
                :expand-macro))
(in-package :codex.macros)

;;; Macros in user input (Docstrings, files, etc.)

(define-node <cl-ref> (<macro-node>)
  ()
  (:tag-name "clref")
  (:documentation "A reference to a Common Lisp symbol."))

(defmethod expand-macro ((ref <cl-ref>))
  (let ((text-node (elt (children ref) 0)))
    (assert (typep text-node '<text-node>))
    (let* ((symbol (text text-node))
           (colon-pos (position #\: symbol))
           (package-name (if colon-pos
                             (subseq symbol 0 colon-pos)))
           (symbol-name (if colon-pos
                            (subseq symbol (1+ colon-pos))
                            symbol)))
      (make-instance '<document-link>
                     :document-reference package-name
                     :section-reference (concatenate 'string
                                                     "sym-" symbol-name)))))

;;; Macros generated by parsing the documentation

(define-node <documentation-node> (<macro-node>)
  ((name :reader op-name
         :initarg :name
         :type string
         :documentation "The name of the operator, variable, or class.")
   (doc :reader op-doc
        :initarg :doc
        :documentation "The node's documentation."))
  (:documentation "Superclass for all documentation nodes."))

(define-node <operator> (<documentation-node>)
 ((lambda-list :reader op-lambda-list
                :initarg :lambda-list
                :type (proper-list string)
                :documentation "The operator's lambda list."))
  (:documentation "The base class of functions and macros."))

(define-node <function> (<operator>)
  ()
  (:documentation "A function."))

(define-node <macro> (<operator>)
  ()
  (:documentation "A macro."))

(define-node <generic-function> (<operator>)
  ()
  (:documentation "A generic function."))

(define-node <variable> (<documentation-node>)
  ()
  (:documentation "A variable."))

(define-node <slot> (<documentation-node>)
  ((accessors :reader slot-accessors
              :initarg :accessors
              :type (proper-list string))
   (readers :reader slot-readers
            :initarg :readers
            :type (proper-list string))
   (writers :reader slot-writers
            :initarg :writers
            :type (proper-list string)))
  (:documentation "A class or structure slot."))

(define-node <record> (<documentation-node>)
  ((slots :reader record-slots
          :initarg :slots
          :type (proper-list <slot>)
          :documentation "A list of slots.")))

(define-node <struct> (<record>)
  ()
  (:documentation "A structure."))

(define-node <class> (<record>)
  ()
  (:documentation "A class."))
