(in-package :cl-user)
(defpackage codex.macros
  (:use :cl :trivial-types)
  (:import-from :common-doc
                :<document-link>
                :<text-node>
                :define-node
                :children
                :text)
  (:import-from :common-doc.macro
                :<macro-node>
                :expand-macro))
(in-package :codex.macros)

;;; Macros in user input (Docstrings, files, etc.)

(define-node <cl-ref> (<macro-node>)
  ()
  (:tag-name "clref")
  (:documentation "A reference to a Common Lisp symbol."))

(defmethod expand-macro ((ref <cl-ref>))
  (let ((text-node (elt (children ref) 0)))
    (assert (typep text-node '<text-node>))
    (let* ((symbol (text text-node))
           (colon-pos (position #\: symbol))
           (package-name (if colon-pos
                             (subseq symbol 0 colon-pos)))
           (symbol-name (if colon-pos
                            (subseq symbol (1+ colon-pos))
                            symbol)))
      (make-instance '<document-link>
                     :document-reference package-name
                     :section-reference (concatenate 'string
                                                     "sym-" symbol-name)))))

;;; Macros generated by parsing the documentation

(define-node <operator> (<macro-node>)
  ((name :reader op-name
         :initarg :name
         :type string
         :documentation "The name of the operator.")
   (doc :reader op-doc
        :initarg :doc
        :documentation "The operator's documentation.")
   (lambda-list :reader op-lambda-list
                :initarg :lambda-list
                :type (proper-list string)
                :documentation "The operator's lambda list."))
  (:documentation "The base class of functions and macros."))

(define-node <function> (<operator>)
  ()
  (:documentation "A function."))

(define-node <macro> (<operator>)
  ()
  (:documentation "A macro."))
