(in-package :cl-user)
(defpackage codex.macros
  (:use :cl :trivial-types)
  (:import-from :common-doc
                :<document-node>
                :<document-link>
                :<text-node>
                :<list-item>
                :<definition>
                :<unordered-list>
                :<definition-list>
                :define-node
                :children
                :text)
  (:import-from :common-doc.macro
                :<macro-node>
                :expand-macro)
  (:import-from :common-doc.util
                :make-meta
                :make-text)
  (:export :*current-package*
           :<cl-ref>
           :<documentation-node>
           :<operator>
           :<function>
           :<macro>
           :<generic-function>
           :<variable>
           :<slot>
           :<record>
           :<struct>
           :<class>
           :name
           :doc
           :lambda-list
           :accessors
           :readers
           :writers
           :slots)
  (:documentation "CommonDoc macros for representing documentation."))
(in-package :codex.macros)

;;; Variables

(defparameter *current-package* "common-lisp")

;;; Utilities

(defun make-class-metadata (class-name)
  "Create metadata for HTML classes."
  (make-meta
   (list
    (cons "class" (concatenate 'string
                               "codex-"
                               class-name)))))

;;; Macros in user input (Docstrings, files, etc.)

(define-node <cl-ref> (<macro-node>)
  ()
  (:tag-name "clref")
  (:documentation "A reference to a Common Lisp symbol."))

;;; Macros generated by parsing the documentation

(define-node <documentation-node> (<macro-node>)
  ((doc-name :reader doc-name
             :initarg :name
             :type string
             :documentation "The name of the operator, variable, or class.")
   (doc-doc :reader doc-description
            :initarg :doc
            :type <document-node>
            :documentation "The node's documentation."))
  (:documentation "Superclass for all documentation nodes."))

(define-node <operator> (<documentation-node>)
 ((lambda-list :reader op-lambda-list
                :initarg :lambda-list
                :type (proper-list string)
                :documentation "The operator's lambda list."))
  (:documentation "The base class of functions and macros."))

(define-node <function> (<operator>)
  ()
  (:documentation "A function."))

(define-node <macro> (<operator>)
  ()
  (:documentation "A macro."))

(define-node <generic-function> (<operator>)
  ()
  (:documentation "A generic function."))

(define-node <variable> (<documentation-node>)
  ()
  (:documentation "A variable."))

(define-node <slot> (<documentation-node>)
  ((accessors :reader slot-accessors
              :initarg :accessors
              :initform nil
              :type (proper-list string))
   (readers :reader slot-readers
            :initarg :readers
            :initform nil
            :type (proper-list string))
   (writers :reader slot-writers
            :initarg :writers
            :initform nil
            :type (proper-list string)))
  (:documentation "A class or structure slot."))

(define-node <record> (<documentation-node>)
  ((slots :reader record-slots
          :initarg :slots
          :type (proper-list <slot>)
          :documentation "A list of slots.")))

(define-node <struct> (<record>)
  ()
  (:documentation "A structure."))

(define-node <class> (<record>)
  ()
  (:documentation "A class."))

;;; Macroexpansions

(defmethod expand-macro ((ref <cl-ref>))
  (let ((text-node (elt (children ref) 0)))
    (assert (typep text-node '<text-node>))
    (let* ((symbol (text text-node))
           (colon-pos (position #\: symbol))
           (package-name (if colon-pos
                             (subseq symbol 0 colon-pos)
                             *current-package*))
           (symbol-name (if colon-pos
                            (subseq symbol (1+ colon-pos))
                            symbol)))
      (make-instance '<document-link>
                     :document-reference package-name
                     :section-reference (concatenate 'string
                                                     "symbol-"
                                                     symbol-name)))))

(defmethod expand-macro ((slot <slot>))
  (labels ((list-of-strings-to-list (strings)
             (make-instance '<unordered-list>
                            :children
                            (loop for string in strings collecting
                              (make-instance '<list-item>
                                             :children
                                             (list (make-text string))))))
           (make-definition (slot-name text)
             (when (slot-value slot slot-name)
               (make-instance '<definition>
                              :term (make-text text)
                              :definition (list-of-strings-to-list
                                           (slot-value slot slot-name))))))
    (let* ((accessors-definition (make-definition 'accessors "Accessors"))
           (readers-definition (make-definition 'readers "Readers"))
           (writers-definition (make-definition 'writers "Writers"))
           (slot-methods (remove-if #'null (list accessors-definition
                                                 readers-definition
                                                 writers-definition)))
           (slot-methods-node (make-instance '<definition-list>
                                             :metadata (make-class-metadata "slot-methods")
                                             :children slot-methods)))
      (make-instance '<content-node>
                     :metadata (make-class-metadata "slot")
                     :children
                     (list (doc-description slot)
                           slot-methods-node)))))

(defmethod expand-macro ((struct <struct>))
  (make-instance '<content-node>
                 :metadata (make-class-metadata "struct")
                 :children
                 (list (doc-description struct)
                       (record-slots struct))))

(defmethod expand-macro ((class <class>))
  (make-instance '<content-node>
                 :metadata (make-class-metadata "class")
                 :children
                 (list (doc-description class)
                       (record-slots class))))
